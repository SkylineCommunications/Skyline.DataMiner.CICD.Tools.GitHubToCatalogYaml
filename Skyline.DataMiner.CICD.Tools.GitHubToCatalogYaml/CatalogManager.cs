namespace Skyline.DataMiner.CICD.Tools.GitHubToCatalogYaml
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    using Microsoft.Extensions.Logging;

    using Skyline.DataMiner.CICD.FileSystem;

    using YamlDotNet.Serialization;
    using YamlDotNet.Serialization.NamingConventions;

    internal class CatalogManager
    {
        private readonly IFileSystem fs;
        private readonly ILogger logger;
        private readonly IGitHubService service;
        private readonly string workspace;

        /// <summary>
        /// Initializes a new instance of the <see cref="CatalogManager"/> class.
        /// </summary>
        /// <param name="fs">The file system abstraction to handle file operations.</param>
        /// <param name="logger">The logger instance for logging messages.</param>
        /// <param name="service">The GitHub service for interacting with repository data.</param>
        /// <param name="workspace">The workspace directory where the catalog and manifest files are located.</param>
        public CatalogManager(IFileSystem fs, ILogger logger, IGitHubService service, string workspace)
        {
            this.fs = fs;
            this.logger = logger;
            this.service = service;
            this.workspace = workspace;
        }

        /// <summary>
        /// Processes the catalog YAML file for the specified GitHub repository. It checks and updates various fields such as ID, description, tags, title, and type.
        /// If no catalog file is found, it attempts to create one from the manifest file.
        /// </summary>
        /// <param name="repoName">The name of the GitHub repository to process.</param>
        /// <param name="catalogIdentifier">The catalog identifier to be used in processing the catalog YAML file.</param>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="repoName"/> or <paramref name="catalogIdentifier"/> is null or empty.</exception>
        /// <returns>A task that represents the asynchronous operation.</returns>
        public async Task ProcessCatalogYamlAsync(string repoName, string catalogIdentifier = "")
        {
            if (String.IsNullOrWhiteSpace(repoName)) throw new ArgumentNullException(nameof(repoName));

            logger.LogInformation("Extracting Information from GitHub...");

            var deserializer = new DeserializerBuilder()
                               .WithNamingConvention(UnderscoredNamingConvention.Instance)
                               .Build();

            var serializer = new SerializerBuilder()
                             .WithNamingConvention(UnderscoredNamingConvention.Instance)
                             .WithIndentedSequences()
                             .Build();

            CatalogYaml catalogYaml = CreateCatalogYaml(deserializer, out string filePath);
            CatalogYaml autoGeneratedCatalogYaml = CreateAutoGeneratedCatalogYaml(deserializer, out string autoGenFilePath);

            CheckId(catalogYaml, autoGeneratedCatalogYaml, catalogIdentifier);

            await CheckShortDescription(catalogYaml);

            CheckSourceCodeUrl(catalogYaml, repoName);

            await CheckTags(catalogYaml);

            CleanTitle parsedRepoName = CheckTitle(repoName, catalogYaml);

            // Perform this after CheckTags.
            CheckType(catalogYaml, parsedRepoName);

            string outputPath = filePath ?? fs.Path.Combine(workspace, "catalog.yml");
            string autoGeneratedOutputPath = autoGenFilePath ?? fs.Path.Combine(workspace, ".githubtocatalog", "auto-generated-catalog.yml");

            // Save both the catalog.yml and the auto-generated-catalog.yml
            // The auto-generated-catalog.yml will be committed & pushed by the pipeline when changed.
            SaveFile(catalogYaml, serializer, outputPath);
            logger.LogInformation($"Finished. Updated or Created file with path: {outputPath}");
            SaveFile(catalogYaml, serializer, autoGeneratedOutputPath);
            logger.LogInformation($"Finished. Updated or Created auto-generated file with path: {autoGeneratedOutputPath}");
        }

        /// <summary>
        /// Infers the artifact content type based on the provided keyword. It checks if the keyword is in the artifact type map and returns the corresponding content type.
        /// </summary>
        /// <param name="keyword">The keyword to infer the artifact content type from.</param>
        /// <returns>The inferred content type, or an empty string if the keyword is not recognized.</returns>
        private static string InferArtifactContentType(string keyword)
        {
            // Check if the keyword exists in the dictionary
            var contentType = Constants.ArtifactTypeMap.FirstOrDefault(p => p.IsMatch(keyword));
            if (contentType != null)
            {
                return contentType.CatalogName;
            }
            else
            {
                return String.Empty;
            }
        }

        /// <summary>
        /// Checks and sets the ID field in the provided catalog YAML.
        /// If the ID is not present or is empty, it attempts to retrieve or create a new ID using the provided catalog identifier, or the ID from the auto-generated catalog YAML.
        /// </summary>
        /// <param name="catalogYaml">The catalog YAML object to check and update.</param>
        /// <param name="autoGeneratedCatalogYaml">The auto-generated catalog YAML object used to retrieve the ID if necessary.</param>
        /// <param name="catalogIdentifier">The catalog identifier to be used if no ID is present in the catalog YAML.</param>
        private void CheckId(CatalogYaml catalogYaml, CatalogYaml autoGeneratedCatalogYaml, string catalogIdentifier)
        {
            logger.LogDebug("Checking if ID was user provided, otherwise retrieve or create it...");
            if (String.IsNullOrWhiteSpace(catalogYaml.Id))
            {
                var catalogId = catalogIdentifier;
                if (String.IsNullOrWhiteSpace(catalogId))
                {
                    if (String.IsNullOrWhiteSpace(autoGeneratedCatalogYaml.Id))
                    {
                        logger.LogDebug("Creating new ID...");
                        catalogId = Guid.NewGuid().ToString();
                        logger.LogDebug("New Catalog ID created.");
                    }
                    else
                    {
                        logger.LogDebug("ID was previously generated and retrieved from auto-generated-catalog.yml.");
                        catalogId = autoGeneratedCatalogYaml.Id;
                    }
                }

                catalogYaml.Id = catalogId;
            }
        }

        /// <summary>
        /// Checks if the short description exists in the YAML file. If it does not, it retrieves the repository description from GitHub and updates the YAML file.
        /// If no description is found, it defaults to "No description available."
        /// </summary>
        /// <param name="catalogYaml">The catalog YAML object to check and update.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        private async Task CheckShortDescription(CatalogYaml catalogYaml)
        {
            logger.LogDebug("Checking if Short_description exists, otherwise retrieve the GitHub repository description...");
            if (String.IsNullOrWhiteSpace(catalogYaml.ShortDescription))
            {
                var description = await service.GetRepositoryDescriptionAsync() ?? "No description available";

                catalogYaml.ShortDescription = description;
                logger.LogDebug($"Description applied: {description}");
            }
        }

        /// <summary>
        /// Checks and sets the SourceCodeUrl field in the provided catalog YAML.
        /// If the SourceCodeUrl is not present or is empty, it assigns a GitHub repository URL based on the provided repository name.
        /// </summary>
        /// <param name="catalogYaml">The catalog YAML object to check and update.</param>
        /// <param name="repoName">The name of the GitHub repository to generate the SourceCodeUrl.</param>
        private void CheckSourceCodeUrl(CatalogYaml catalogYaml, string repoName)
        {
            logger.LogDebug("Checking if SourceCodeUrl exists, otherwise create sourcecode url from repository name...");
            if (String.IsNullOrWhiteSpace(catalogYaml.SourceCodeUrl))
            {
                var sourceCodeUrl = "https://github.com/" + repoName;
                catalogYaml.SourceCodeUrl = sourceCodeUrl;
                logger.LogDebug($"Sourcecode url applied: {sourceCodeUrl}");
            }
        }

        /// <summary>
        /// Checks if the tags exist in the YAML file. If they are missing, it retrieves repository topics from GitHub and adds them to the YAML file, ensuring that the tags are distinct.
        /// </summary>
        /// <param name="catalogYaml">The catalog YAML object to check and update.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        private async Task CheckTags(CatalogYaml catalogYaml)
        {
            logger.LogDebug("Checking if Tags exist, extending with retrieved GitHub repository topics...");
            if (catalogYaml.Tags == null || catalogYaml.Tags.Count == 0)
            {
                catalogYaml.Tags = new List<string>();
            }

            var topics = await service.GetRepositoryTopicsAsync();
            if (topics is { Count: > 0 })
            {
                catalogYaml.Tags.AddRange(topics);

                // Remove duplicates
                catalogYaml.Tags = catalogYaml.Tags.Distinct().ToList();
                logger.LogDebug("Distinct GitHub Topics found and applied.");
            }
        }

        /// <summary>
        /// Checks if the title exists in the YAML file. If it does not, a cleaned version of the repository name is used as the title.
        /// </summary>
        /// <param name="repoName">The repository name to generate a title if needed.</param>
        /// <param name="catalogYaml">The catalog YAML object to check and update.</param>
        /// <returns>A <see cref="CleanTitle"/> object representing the cleaned repository name.</returns>
        private CleanTitle CheckTitle(string repoName, CatalogYaml catalogYaml)
        {
            logger.LogDebug("Checking if Title exists, otherwise use a cleaned-up version of the repository name...");
            var parsedRepoName = new CleanTitle(repoName);
            if (String.IsNullOrWhiteSpace(catalogYaml.Title))
            {
                catalogYaml.Title = parsedRepoName.Value;
                logger.LogDebug($"GitHub Repository Name cleaned and applied {catalogYaml.Title}.");
            }

            return parsedRepoName;
        }

        /// <summary>
        /// Checks if the type exists in the YAML file. If not, it attempts to infer the type from the repository name or tags.
        /// If it cannot identify the type, it throws an <see cref="InvalidOperationException"/>.
        /// </summary>
        /// <param name="catalogYaml">The catalog YAML object to check and update.</param>
        /// <param name="parsedRepoName">The parsed repository name to use for type inference.</param>
        /// <exception cref="InvalidOperationException">Thrown when the type cannot be identified from the repository name or tags.</exception>
        private void CheckType(CatalogYaml catalogYaml, CleanTitle parsedRepoName)
        {
            logger.LogDebug("Checking if Type exists, otherwise infer it from repository name or topics...");
            if (!String.IsNullOrWhiteSpace(catalogYaml.Type))
            {
                return;
            }

            // First, check repository name for item type acronym
            if (parsedRepoName.FoundItemType != null)
            {
                catalogYaml.Type = parsedRepoName.FoundItemType;
                logger.LogDebug($"Item Type could be inferred from repository name {catalogYaml.Type}.");
            }

            // Always check the tags
            if (catalogYaml.Tags != null)
            {
                foreach (var topic in catalogYaml.Tags)
                {
                    var inferredType = InferArtifactContentType(topic);
                    if (!String.IsNullOrWhiteSpace(inferredType))
                    {
                        catalogYaml.Type = inferredType;
                        catalogYaml.Tags.Remove(topic);
                        logger.LogDebug($"Item Type could be inferred from repository topics {catalogYaml.Type}.");
                        break;
                    }
                }
            }

            if (String.IsNullOrWhiteSpace(catalogYaml.Type))
            {
                // On request of ECS
                throw new InvalidOperationException("Could not identify Type from GitHub. Please specify the type either through naming or topic guidelines.");
            }
        }

        /// <summary>
        /// Creates a new catalog YAML object by reading the existing catalog.yml or manifest.yml file in the workspace.
        /// If no file is found, it creates an empty catalog YAML object.
        /// </summary>
        /// <param name="deserializer">The YAML deserializer to parse the existing YAML file.</param>
        /// <param name="foundFile">The path to the found YAML file, or null if no file is found.</param>
        /// <returns>The deserialized <see cref="CatalogYaml"/> object, or a new object if no file is found.</returns>
        private CatalogYaml CreateAutoGeneratedCatalogYaml(IDeserializer deserializer, out string foundFile)
        {
            logger.LogDebug("Checking if ");
            foundFile = null;

            string filePath = fs.Path.Combine(workspace, ".githubtocatalog", "auto-generated-catalog.yml");
            if (!fs.File.Exists(filePath))
            {
                logger.LogDebug("No existing auto-generated configuration file found.");
            }
            else
            {
                foundFile = filePath;
                logger.LogDebug($"Found auto-generated file at: {filePath}");
            }

            if (String.IsNullOrWhiteSpace(foundFile))
            {
                return new CatalogYaml();
            }

            var yamlContent = fs.File.ReadAllText(filePath);
            logger.LogDebug("Existing Configuration File Parsed.");
            return deserializer.Deserialize<CatalogYaml>(yamlContent) ?? new CatalogYaml();
        }

        /// <summary>
        /// Creates a new catalog YAML object by reading the existing catalog.yml or manifest.yml file in the workspace.
        /// If no file is found, it creates an empty catalog YAML object.
        /// </summary>
        /// <param name="deserializer">The YAML deserializer to parse the existing YAML file.</param>
        /// <param name="foundFile">The path to the found YAML file, or null if no file is found.</param>
        /// <returns>The deserialized <see cref="CatalogYaml"/> object, or a new object if no file is found.</returns>
        private CatalogYaml CreateCatalogYaml(IDeserializer deserializer, out string foundFile)
        {
            logger.LogDebug("Checking if user has provided a catalog.yml or manifest.yml file within the workspace root.");
            foundFile = null;

            string filePath = fs.Path.Combine(workspace, "catalog.yml");
            if (!fs.File.Exists(filePath))
            {
                filePath = fs.Path.Combine(workspace, "manifest.yml");
                if (!fs.File.Exists(filePath))
                {
                    logger.LogDebug("No existing configuration file found.");
                }
                else
                {
                    foundFile = filePath;
                    logger.LogDebug($"Found file at: {filePath}");
                }
            }
            else
            {
                foundFile = filePath;
                logger.LogDebug($"Found file at: {filePath}");
            }

            if (String.IsNullOrWhiteSpace(foundFile))
            {
                return new CatalogYaml();
            }

            var yamlContent = fs.File.ReadAllText(filePath);
            logger.LogDebug("Existing Configuration File Parsed.");
            return deserializer.Deserialize<CatalogYaml>(yamlContent) ?? new CatalogYaml();
        }

        /// <summary>
        /// Serializes the catalog YAML object and saves it to the specified output path.
        /// </summary>
        /// <param name="catalogYaml">The catalog YAML object to serialize.</param>
        /// <param name="serializer">The YAML serializer used to convert the object to YAML format.</param>
        /// <param name="outputPath">The file path where the updated YAML file will be saved.</param>
        private void SaveFile(CatalogYaml catalogYaml, ISerializer serializer, string outputPath)
        {
            logger.LogDebug($"Serializing and saving the updated catalog.yml file with path: {outputPath}.");
            // Delete the file if it already exists. Overwriting an existing file is not allowed in GitHub.
            fs.File.DeleteFile(outputPath);
            Thread.Sleep(500);
            var updatedYaml = serializer.Serialize(catalogYaml);

            var parentDir = fs.Path.GetDirectoryName(outputPath);
            fs.Directory.CreateDirectory(parentDir);
            fs.Directory.TryAllowWritesOnDirectory(parentDir);

            fs.File.WriteAllText(outputPath, updatedYaml);
        }
    }
}